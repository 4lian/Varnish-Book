=version $Id: installation.pds,v 1.5 2005-12-19 13:06:51 lars Exp $
=topic Architecture

=slide Design principles

<ul>
  <li>Optimized for 64-bit
    <ul>
      <li>Also support for 32bit</li>
    </ul>
  </li>
  <li>Optimized for multi-core / multi-processor
    <ul>
      <li>Also supports single-core / single-processor</li>
    </ul> 
  </li>
  <li>Work with the kernel, not against it
     <ul>
      <li>Don't second-guess the VM system</li>
      <li>Give the VM system hints on what you are going to do</li>
    </ul> 
  </li>
  <li>Take advantage of advanced facilities
  <ul>
      <li>epoll, kqueue, accept filters...</li>
    </ul> 
  </li>
  <li>Groundbreaking design
  <ul>
      <li>VCL</li>
      <li>shared memory log file</li>
      <li>Smarter strings</li>
    </ul> 
  </li>
  <li>Minimize the amount of work done in the fast path
  <ul>
      <li>Delegate non-essential work to support applications</li>
    </ul>
  </li>

</ul>

=comments

<p>When Varnish was planned, it was decided early on to focus on
high-performance, flexibility and stability. That meant making some
sacrifices.</p>

<p>Varnish is designed for hardware that you buy today, not the hardware
you bought 15 years ago. Varnish is designed to run on 64-bit
architectures and will scale almost proportional to the number of CPU cores
you have available. Though CPU is rarely a problem.</p>

<p>If you choose to run Varnish on a 32-bit system, you are limited to 2GB
of virtual memory, which puts a limit on the number of threads you can run
and the size of your cache. This is a trade-off to gain a simpler design
and reduce the amount of work Varnish needs to do.</p>

<p>Varnish does not keep track of whether your cache is on disk or in
memory, as the operating system do a far better job at this. Instead,
Varnish will simply request a large chump of memory and leave it to the
operating system to figure out where that memory really is.</p>

<p>Features like accept filters, epoll and kqueue are advanced features of
the operating system that are designed for high-performance services like
Varnish.</p>

<p>In addition, Varnish uses a configuration language that is translated to
C-code, compiled with a normal C compiler and then linked directly into
Varnish at run-time. This has several advantages, like allowing you to use
the optimizations of your C-compiler, and adapting Varnish to your exact
needs even if the developers didn't see your specific use-case.</p>

<p>The shared memory log allow Varnish to log extensive information at
almost no cost by having other applications parse the data and extract the
useful bits. This is important to reduce the lock-contention in a heavily
threaded environment like Varnish. Lock-contention is also one of the
reasons why Varnish uses a workspace-oriented memory-model instead of only
allocating the exact amount of space it needs at run-time.</p>

=slide Architecture

<img width="855" src="bilder/varnish-2.0.4-flow.jpg" />
